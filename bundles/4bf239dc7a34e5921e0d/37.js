(window.webpackJsonp=window.webpackJsonp||[]).push([[37],{1708:function(e,t,s){"use strict";s.r(t),s.d(t,"initRustCrypto",(function(){return y}));var o=s(494),n=s(13),i=s.n(n),r=s(1),a=s(367),c=s(130);class u{constructor(e,t,s,o){this.olmMachine=e,this.keyClaimManager=t,this.room=s,this.encryptionSettings=o,i()(this,"prefixedLogger",void 0),this.prefixedLogger=r.a.withPrefix(`[${s.roomId} encryption]`)}onCryptoEvent(e){JSON.stringify(this.encryptionSettings)!=JSON.stringify(e)&&this.prefixedLogger.error("Ignoring m.room.encryption event which requests a change of config")}onRoomMembership(e){this.prefixedLogger.debug(`${e.membership} event for ${e.userId}`),("join"==e.membership||"invite"==e.membership&&this.room.shouldEncryptForInvitedMembers())&&(this.prefixedLogger.debug(`starting to track devices for: ${e.userId}`),this.olmMachine.updateTrackedUsers([new o.UserId(e.userId)]))}async ensureEncryptionSession(){if("m.megolm.v1.aes-sha2"!==this.encryptionSettings.algorithm)throw new Error(`Cannot encrypt in ${this.room.roomId} for unsupported algorithm '${this.encryptionSettings.algorithm}'`);const e=await this.room.getEncryptionTargetMembers();this.prefixedLogger.debug(`Encrypting for users (shouldEncryptForInvitedMembers: ${this.room.shouldEncryptForInvitedMembers()}):`,e.map((e=>`${e.userId} (${e.membership})`)));const t=e.map((e=>new o.UserId(e.userId)));await this.keyClaimManager.ensureSessionsForUsers(t);const s=new o.EncryptionSettings;await this.olmMachine.shareRoomKey(new o.RoomId(this.room.roomId),t,s)}async encryptEvent(e){await this.ensureEncryptionSession();const t=await this.olmMachine.encryptRoomEvent(new o.RoomId(this.room.roomId),e.getType(),JSON.stringify(e.getContent()));e.makeEncrypted(c.b.RoomMessageEncrypted,JSON.parse(t),this.olmMachine.identityKeys.curve25519.toBase64(),this.olmMachine.identityKeys.ed25519.toBase64())}}var h=s(196);class p{constructor(e,t){this.olmMachine=e,this.http=t}async makeOutgoingRequest(e){let t;if(e instanceof o.KeysUploadRequest)t=await this.rawJsonRequest(h.i.Post,"/_matrix/client/v3/keys/upload",{},e.body);else if(e instanceof o.KeysQueryRequest)t=await this.rawJsonRequest(h.i.Post,"/_matrix/client/v3/keys/query",{},e.body);else if(e instanceof o.KeysClaimRequest)t=await this.rawJsonRequest(h.i.Post,"/_matrix/client/v3/keys/claim",{},e.body);else if(e instanceof o.SignatureUploadRequest)t=await this.rawJsonRequest(h.i.Post,"/_matrix/client/v3/keys/signatures/upload",{},e.body);else if(e instanceof o.KeysBackupRequest)t=await this.rawJsonRequest(h.i.Put,"/_matrix/client/v3/room_keys/keys",{},e.body);else if(e instanceof o.ToDeviceRequest){const s=`/_matrix/client/v3/sendToDevice/${encodeURIComponent(e.event_type)}/`+encodeURIComponent(e.txn_id);t=await this.rawJsonRequest(h.i.Put,s,{},e.body)}else if(e instanceof o.RoomMessageRequest){const s=`/_matrix/client/v3/room/${encodeURIComponent(e.room_id)}/send/${encodeURIComponent(e.event_type)}/${encodeURIComponent(e.txn_id)}`;t=await this.rawJsonRequest(h.i.Put,s,{},e.body)}else r.a.warn("Unsupported outgoing message",Object.getPrototypeOf(e)),t="";e.id&&await this.olmMachine.markRequestAsSent(e.id,e.type,t)}async rawJsonRequest(e,t,s,o){const n={json:!1,headers:{"Content-Type":"application/json",Accept:"application/json"},prefix:""};try{const i=await this.http.authedRequest(e,t,s,o,n);return r.a.info(`rust-crypto: successfully made HTTP request: ${e} ${t}`),i}catch(s){throw r.a.warn(`rust-crypto: error making HTTP request: ${e} ${t}: ${s}`),s}}}class m{constructor(e,t){this.olmMachine=e,this.outgoingRequestProcessor=t,i()(this,"currentClaimPromise",void 0),i()(this,"stopped",!1),this.currentClaimPromise=Promise.resolve()}stop(){this.stopped=!0}ensureSessionsForUsers(e){const t=this.currentClaimPromise.finally((()=>this.ensureSessionsForUsersInner(e)));return this.currentClaimPromise=t,t}async ensureSessionsForUsersInner(e){if(this.stopped)throw new Error("Cannot ensure Olm sessions: shutting down");const t=await this.olmMachine.getMissingSessions(e);t&&await this.outgoingRequestProcessor.makeOutgoingRequest(t)}}class g{constructor(e,t,s,o){this.olmMachine=e,i()(this,"globalBlacklistUnverifiedDevices",!1),i()(this,"globalErrorOnUnknownDevices",!1),i()(this,"stopped",!1),i()(this,"outgoingRequestLoopRunning",!1),i()(this,"roomEncryptors",{}),i()(this,"keyClaimManager",void 0),i()(this,"outgoingRequestProcessor",void 0),this.outgoingRequestProcessor=new p(e,t),this.keyClaimManager=new m(e,this.outgoingRequestProcessor)}stop(){this.stopped||(this.stopped=!0,this.keyClaimManager.stop(),this.olmMachine.close())}prepareToEncrypt(e){const t=this.roomEncryptors[e.roomId];t&&t.ensureEncryptionSession()}async encryptEvent(e,t){const s=e.getRoomId(),o=this.roomEncryptors[s];if(!o)throw new Error(`Cannot encrypt event in unconfigured room ${s}`);await o.encryptEvent(e)}async decryptEvent(e){if(!e.getRoomId())throw new Error("to-device event was not decrypted in preprocessToDeviceMessages");const t=await this.olmMachine.decryptRoomEvent(JSON.stringify({event_id:e.getId(),type:e.getWireType(),sender:e.getSender(),state_key:e.getStateKey(),content:e.getWireContent(),origin_server_ts:e.getTs()}),new o.RoomId(e.getRoomId()));return{clearEvent:JSON.parse(t.event),claimedEd25519Key:t.senderClaimedEd25519Key,senderCurve25519Key:t.senderCurve25519Key,forwardingCurve25519KeyChain:t.forwardingCurve25519KeyChain}}getEventEncryptionInfo(e){var t;const s={};return s.senderKey=null!==(t=e.getSenderKey())&&void 0!==t?t:void 0,s.algorithm=e.getWireContent().algorithm,s.senderKey&&s.algorithm?(s.encrypted=!0,s.authenticated=!0,s.mismatchedSender=!0,s):(s.encrypted=!1,s)}async userHasCrossSigningKeys(){return!1}async exportRoomKeys(){return[]}checkUserTrust(e){return new a.c(!1,!1,!1)}checkDeviceTrust(e,t){return new a.b(!1,!1,!1,!1)}async preprocessToDeviceMessages(e){const t=await this.olmMachine.receiveSyncChanges(JSON.stringify(e),new o.DeviceLists,new Map,new Set);return JSON.parse(t)}async onCryptoEvent(e,t){const s=t.getContent(),n=this.roomEncryptors[e.roomId];n?n.onCryptoEvent(s):this.roomEncryptors[e.roomId]=new u(this.olmMachine,this.keyClaimManager,e,s);const i=await e.getEncryptionTargetMembers();r.a.debug(`[${e.roomId} encryption] starting to track devices for: `,i.map((e=>`${e.userId} (${e.membership})`))),await this.olmMachine.updateTrackedUsers(i.map((e=>new o.UserId(e.userId))))}onSyncCompleted(e){this.outgoingRequestLoop()}onRoomMembership(e,t,s){const o=this.roomEncryptors[e.getRoomId()];o&&o.onRoomMembership(t)}async outgoingRequestLoop(){if(!this.outgoingRequestLoopRunning){this.outgoingRequestLoopRunning=!0;try{for(;!this.stopped;){const e=await this.olmMachine.outgoingRequests();if(0==e.length||this.stopped)return;for(const t of e)await this.outgoingRequestProcessor.makeOutgoingRequest(t)}}catch(e){r.a.error("Error processing outgoing-message requests from rust crypto-sdk",e)}finally{this.outgoingRequestLoopRunning=!1}}}}var d=s(712);async function y(e,t,s){await o.initAsync(),new o.Tracing(o.LoggerLevel.Debug).turnOn();const n=new o.UserId(t),i=new o.DeviceId(s);r.a.info("Init OlmMachine");const a=await o.OlmMachine.initialize(n,i,d.a,"test pass"),c=new g(a,e,t,s);return r.a.info("Completed rust crypto-sdk setup"),c}}}]);
//# sourceMappingURL=37.js.map