(window.webpackJsonp=window.webpackJsonp||[]).push([[37],{1747:function(e,t,s){"use strict";s.r(t),s.d(t,"initRustCrypto",(function(){return v}));var n=s(502),o=s(13),i=s.n(o),r=s(1),a=s(376),c=s(130);class d{constructor(e,t,s,n,o){this.olmMachine=e,this.keyClaimManager=t,this.outgoingRequestProcessor=s,this.room=n,this.encryptionSettings=o,i()(this,"prefixedLogger",void 0),this.prefixedLogger=r.a.withPrefix(`[${n.roomId} encryption]`)}onCryptoEvent(e){JSON.stringify(this.encryptionSettings)!=JSON.stringify(e)&&this.prefixedLogger.error("Ignoring m.room.encryption event which requests a change of config")}onRoomMembership(e){this.prefixedLogger.debug(`${e.membership} event for ${e.userId}`),("join"==e.membership||"invite"==e.membership&&this.room.shouldEncryptForInvitedMembers())&&(this.prefixedLogger.debug(`starting to track devices for: ${e.userId}`),this.olmMachine.updateTrackedUsers([new n.UserId(e.userId)]))}async ensureEncryptionSession(){if("m.megolm.v1.aes-sha2"!==this.encryptionSettings.algorithm)throw new Error(`Cannot encrypt in ${this.room.roomId} for unsupported algorithm '${this.encryptionSettings.algorithm}'`);const e=await this.room.getEncryptionTargetMembers();this.prefixedLogger.debug(`Encrypting for users (shouldEncryptForInvitedMembers: ${this.room.shouldEncryptForInvitedMembers()}):`,e.map((e=>`${e.userId} (${e.membership})`)));const t=e.map((e=>new n.UserId(e.userId)));await this.keyClaimManager.ensureSessionsForUsers(t),this.prefixedLogger.debug("Sessions for users are ready; now sharing room key");const s=new n.EncryptionSettings,o=await this.olmMachine.shareRoomKey(new n.RoomId(this.room.roomId),t,s);if(o)for(const e of o)await this.outgoingRequestProcessor.makeOutgoingRequest(e)}async forceDiscardSession(){await this.olmMachine.invalidateGroupSession(new n.RoomId(this.room.roomId))&&this.prefixedLogger.info("Discarded existing group session")}async encryptEvent(e){await this.ensureEncryptionSession();const t=await this.olmMachine.encryptRoomEvent(new n.RoomId(this.room.roomId),e.getType(),JSON.stringify(e.getContent()));e.makeEncrypted(c.b.RoomMessageEncrypted,JSON.parse(t),this.olmMachine.identityKeys.curve25519.toBase64(),this.olmMachine.identityKeys.ed25519.toBase64())}}var g=s(190);class h{constructor(e,t){this.olmMachine=e,this.http=t}async makeOutgoingRequest(e){let t;if(e instanceof n.KeysUploadRequest)t=await this.rawJsonRequest(g.i.Post,"/_matrix/client/v3/keys/upload",{},e.body);else if(e instanceof n.KeysQueryRequest)t=await this.rawJsonRequest(g.i.Post,"/_matrix/client/v3/keys/query",{},e.body);else if(e instanceof n.KeysClaimRequest)t=await this.rawJsonRequest(g.i.Post,"/_matrix/client/v3/keys/claim",{},e.body);else if(e instanceof n.SignatureUploadRequest)t=await this.rawJsonRequest(g.i.Post,"/_matrix/client/v3/keys/signatures/upload",{},e.body);else if(e instanceof n.KeysBackupRequest)t=await this.rawJsonRequest(g.i.Put,"/_matrix/client/v3/room_keys/keys",{},e.body);else if(e instanceof n.ToDeviceRequest){const s=`/_matrix/client/v3/sendToDevice/${encodeURIComponent(e.event_type)}/`+encodeURIComponent(e.txn_id);t=await this.rawJsonRequest(g.i.Put,s,{},e.body)}else if(e instanceof n.RoomMessageRequest){const s=`/_matrix/client/v3/room/${encodeURIComponent(e.room_id)}/send/${encodeURIComponent(e.event_type)}/${encodeURIComponent(e.txn_id)}`;t=await this.rawJsonRequest(g.i.Put,s,{},e.body)}else r.a.warn("Unsupported outgoing message",Object.getPrototypeOf(e)),t="";e.id&&await this.olmMachine.markRequestAsSent(e.id,e.type,t)}async rawJsonRequest(e,t,s,n){const o={json:!1,headers:{"Content-Type":"application/json",Accept:"application/json"},prefix:""};try{const i=await this.http.authedRequest(e,t,s,n,o);return r.a.info(`rust-crypto: successfully made HTTP request: ${e} ${t}`),i}catch(s){throw r.a.warn(`rust-crypto: error making HTTP request: ${e} ${t}: ${s}`),s}}}class u{constructor(e,t){this.olmMachine=e,this.outgoingRequestProcessor=t,i()(this,"currentClaimPromise",void 0),i()(this,"stopped",!1),this.currentClaimPromise=Promise.resolve()}stop(){this.stopped=!0}ensureSessionsForUsers(e){const t=this.currentClaimPromise.catch((()=>{})).then((()=>this.ensureSessionsForUsersInner(e)));return this.currentClaimPromise=t,t}async ensureSessionsForUsersInner(e){if(this.stopped)throw new Error("Cannot ensure Olm sessions: shutting down");const t=await this.olmMachine.getMissingSessions(e);t&&await this.outgoingRequestProcessor.makeOutgoingRequest(t)}}var p=s(16);class m{constructor(e,t,s,n){this.olmMachine=e,i()(this,"globalErrorOnUnknownDevices",!1),i()(this,"stopped",!1),i()(this,"outgoingRequestLoopRunning",!1),i()(this,"roomEncryptors",{}),i()(this,"eventDecryptor",void 0),i()(this,"keyClaimManager",void 0),i()(this,"outgoingRequestProcessor",void 0),i()(this,"globalBlacklistUnverifiedDevices",!1),this.outgoingRequestProcessor=new h(e,t),this.keyClaimManager=new u(e,this.outgoingRequestProcessor),this.eventDecryptor=new y(e)}stop(){this.stopped||(this.stopped=!0,this.keyClaimManager.stop(),this.olmMachine.close())}async encryptEvent(e,t){const s=e.getRoomId(),n=this.roomEncryptors[s];if(!n)throw new Error(`Cannot encrypt event in unconfigured room ${s}`);await n.encryptEvent(e)}async decryptEvent(e){if(!e.getRoomId())throw new Error("to-device event was not decrypted in preprocessToDeviceMessages");return await this.eventDecryptor.attemptEventDecryption(e)}getEventEncryptionInfo(e){var t;const s={};return s.senderKey=null!==(t=e.getSenderKey())&&void 0!==t?t:void 0,s.algorithm=e.getWireContent().algorithm,s.senderKey&&s.algorithm?(s.encrypted=!0,s.authenticated=!0,s.mismatchedSender=!0,s):(s.encrypted=!1,s)}checkUserTrust(e){return new a.c(!1,!1,!1)}checkDeviceTrust(e,t){return new a.b(!1,!1,!1,!1)}async userHasCrossSigningKeys(){return!1}prepareToEncrypt(e){const t=this.roomEncryptors[e.roomId];t&&t.ensureEncryptionSession()}forceDiscardSession(e){var t;return null===(t=this.roomEncryptors[e])||void 0===t?void 0:t.forceDiscardSession()}async exportRoomKeys(){return[]}async receiveSyncChanges(e){let{events:t,oneTimeKeysCounts:s=new Map,unusedFallbackKeys:o=new Set,devices:i=new n.DeviceLists}=e;const r=await this.olmMachine.receiveSyncChanges(t?JSON.stringify(t):"[]",i,s,o);return JSON.parse(r)}preprocessToDeviceMessages(e){return this.receiveSyncChanges({events:e})}async processKeyCounts(e,t){const s=e&&new Map(Object.entries(e)),n=t&&new Set(t);void 0===s&&void 0===n||await this.receiveSyncChanges({oneTimeKeysCounts:s,unusedFallbackKeys:n})}async processDeviceLists(e){var t,s;const o=new n.DeviceLists(null===(t=e.changed)||void 0===t?void 0:t.map((e=>new n.UserId(e))),null===(s=e.left)||void 0===s?void 0:s.map((e=>new n.UserId(e))));await this.receiveSyncChanges({devices:o})}async onCryptoEvent(e,t){const s=t.getContent(),o=this.roomEncryptors[e.roomId];o?o.onCryptoEvent(s):this.roomEncryptors[e.roomId]=new d(this.olmMachine,this.keyClaimManager,this.outgoingRequestProcessor,e,s);const i=await e.getEncryptionTargetMembers();r.a.debug(`[${e.roomId} encryption] starting to track devices for: `,i.map((e=>`${e.userId} (${e.membership})`))),await this.olmMachine.updateTrackedUsers(i.map((e=>new n.UserId(e.userId))))}onSyncCompleted(e){this.outgoingRequestLoop()}onRoomMembership(e,t,s){const n=this.roomEncryptors[e.getRoomId()];n&&n.onRoomMembership(t)}async onRoomKeysUpdated(e){for(const t of e)this.onRoomKeyUpdated(t)}onRoomKeyUpdated(e){r.a.debug(`Got update for session ${e.senderKey.toBase64()}|${e.sessionId} in ${e.roomId.toString()}`);const t=this.eventDecryptor.getEventsPendingRoomKey(e);if(0!==t.length){r.a.debug("Retrying decryption on events:",t.map((e=>`${e.getId()}`)));for(const e of t)e.attemptDecryption(this,{isRetry:!0}).catch((t=>{r.a.info(`Still unable to decrypt event ${e.getId()} after receiving key`)}))}}async outgoingRequestLoop(){if(!this.outgoingRequestLoopRunning){this.outgoingRequestLoopRunning=!0;try{for(;!this.stopped;){const e=await this.olmMachine.outgoingRequests();if(0==e.length||this.stopped)return;for(const t of e)await this.outgoingRequestProcessor.makeOutgoingRequest(t)}}catch(e){r.a.error("Error processing outgoing-message requests from rust crypto-sdk",e)}finally{this.outgoingRequestLoopRunning=!1}}}}class y{constructor(e){this.olmMachine=e,i()(this,"eventsPendingKey",new p.b((()=>new p.b((()=>new Set)))))}async attemptEventDecryption(e){r.a.info("Attempting decryption of event",e),this.addEventToPendingList(e);const t=await this.olmMachine.decryptRoomEvent(JSON.stringify({event_id:e.getId(),type:e.getWireType(),sender:e.getSender(),state_key:e.getStateKey(),content:e.getWireContent(),origin_server_ts:e.getTs()}),new n.RoomId(e.getRoomId()));return this.removeEventFromPendingList(e),{clearEvent:JSON.parse(t.event),claimedEd25519Key:t.senderClaimedEd25519Key,senderCurve25519Key:t.senderCurve25519Key,forwardingCurve25519KeyChain:t.forwardingCurve25519KeyChain}}getEventsPendingRoomKey(e){const t=this.eventsPendingKey.get(e.senderKey.toBase64());if(!t)return[];const s=t.get(e.sessionId);if(!s)return[];const n=e.roomId.toString();return[...s].filter((e=>e.getRoomId()===n))}addEventToPendingList(e){const t=e.getWireContent(),s=t.sender_key,n=t.session_id;this.eventsPendingKey.getOrCreate(s).getOrCreate(n).add(e)}removeEventFromPendingList(e){const t=e.getWireContent(),s=t.sender_key,n=t.session_id,o=this.eventsPendingKey.get(s);if(!o)return;const i=o.get(n);i&&(i.delete(e),0===i.size&&(o.delete(n),0===o.size&&this.eventsPendingKey.delete(s)))}}var l=s(718);async function v(e,t,s){await n.initAsync(),new n.Tracing(n.LoggerLevel.Trace).turnOn();const o=new n.UserId(t),i=new n.DeviceId(s);r.a.info("Init OlmMachine");const a=await n.OlmMachine.initialize(o,i,l.a,"test pass"),c=new m(a,e,t,s);return await a.registerRoomKeyUpdatedCallback((e=>c.onRoomKeysUpdated(e))),r.a.info("Completed rust crypto-sdk setup"),c}}}]);
//# sourceMappingURL=37.js.map